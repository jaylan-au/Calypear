<style>
.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.links path {
  stroke: #999;
  stroke-opacity: 0.6;
  fill: none;
  /*marker-end: url(#markerArrow);
  marker-mid: url(#markerArrow);*/
}


.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.node-text {
  font-size: 8px;
  text-align: center;
}

.linklabel {
  font-size: 8px;
  text-align: center;
}
</style>
<svg width="100%" height="80%" viewBox="0 0 600 600">
  <defs>
    <marker id="markerArrow" markerWidth="13" markerHeight="13" refX="2" refY="6" orient="auto">
      <path d="M2,2 L2,11 L10,6 L2,2" style="fill: #000000;" />
    </marker>
  </defs>
</svg>
<script src="dist/js/d3.js"></script>
<script>
  var graph = {
    "nodes": [
      {{#each components}}
        {"id": "{{id}}", "name": "{{name}}", "type": {"id": {{type.id}}, "name": "{{type.name}}"} } {{#unless @last}},{{/unless}}
      {{/each}}
    ],
    "links": [
      {{#each relations}}
        {"id": {{id}}, "source": "{{from}}", "target": "{{to}}", "type": {"id": {{type.id}}, "name": "{{type.name}}"}, "distanceAssoc": {{#if type.distance}}{{type.distance}}{{else}}0{{/if}} } {{#unless @last}},{{/unless}}
      {{/each}}
    ]
  };

  var svg = d3.select("svg");
  width = 600;
  height = 600;
      // width = +svg.attr("width"),
      // height = +svg.attr("height");

  var color = d3.scaleOrdinal(d3.schemeCategory20);

  var simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(function(d) { return d.id; }))
      .force("charge", d3.forceManyBody())
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collide", d3.forceCollide(10));


  var connectorGenerator = d3.line()
    .curve(d3.curveBasis);

  var link = svg.append("g")
      .attr("class", "links")
    .selectAll(".link-item")
    .data(graph.links)
    .enter()
      .append("path")
      .attr("class","linkitem")
      .attr("d",function(d) {
        var points = [
          [d.source.x,d.source.y],
          [d.target.x,d.target.y]
        ];
        return connectorGenerator(points);
      })
      .attr("stroke-width", 1)
      .attr("id",function(d) {return "link"+d.id;});

  var linkLabels = svg.append("g")
      .attr("class","linklabels")
    .selectAll(".linklabel")
    .data(graph.links)
    .enter()
      .append("text")
      .attr("class","linklabel")
      .append("textPath")
        .attr("xlink:href",function(d) {return "#link"+d.id;})
        .attr("startOffset","50%")
        .text(function(d) {return d.type.name;});


  function constructLink(context) {
      context.append()
  }

  function constructNode(context) {
    context.append("circle")
      .attr("cx",0)
      .attr("cy",0)
      .attr("r",6)
      .attr("fill",function(d) {return color(d.type.id)});
    //
    // context.append("rect")
    //   .attr("width",120)
    //   .attr("height",15)
    //   .attr("fill",function(d) {return color(d.type)});
    // context.append("rect")
    //   .attr("x",0)
    //   .attr("y",15)
    //   .attr("width",120)
    //   .attr("height",40)
    //   .attr("fill","none");
    // context.append("rect")
    //   .attr("x",0)
    //   .attr("y",0)
    //   .attr("width",120)
    //   .attr("height",55)
    //   .attr("fill","none")
    //   .attr("stroke","#999")
    context.append("foreignObject")
      .attr("x",-40)
      .attr("y",5)
      .attr("width",80)
      .attr("height",40)
      .attr("class","node-text")
      .append("xhtml:p")
        .text(function(d) {return d.name});
    // context.append("text")
    //   .attr("dx", 20)
    //   .attr("dy", "1em")
    //   .attr("class","node-text")
    //   .text(function(d) {return d.name});
  }

  var node = svg.append("g")
      .attr("class", "nodes")
    .selectAll(".nodeitem")
    .data(graph.nodes)
    .enter()
      .append("g")
      .attr("class","nodeitem")
      .on("dblclick", dblclick)
      .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

  constructNode(node);

  // node.append('foreignObject')
  //   .attr("x",0)
  //   .attr("y",0)
  //   .attr("width",150)
  //   .attr("height",100)
  //   .append("xhtml:p")
  //     .text(function(d) { return d.name });


  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links)
      .distance(function(link){return link.distanceAssoc*5;});

  function ticked() {
    link
      .attr("d",function(d) {
        var points = [
          [d.source.x,d.source.y],
          [d.target.x,d.target.y]
        ];
        return connectorGenerator(points);
      });

    node
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  }

  function dragstarted(d) {
    d3.select(this).classed("fixed",true);
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
    //note in D3 \v4 .fixed setting no longer works need to use fx/fy
  }

  function dragged(d) {
    // d.fx = d3.event.x;
    // d.fy = d3.event.y;
    var grid = 10;

    d.fx = Math.round(d3.event.x/grid)*grid;
    d.fy = Math.round(d3.event.y/grid)*grid;

  }

  function dragended(d) {
    //Stop the simulation
    if (!d3.event.active) {
      simulation.alphaTarget(0)
      //If the Ctrl key is held down then lock the node in position
      //Touching the node again will free it
      //Need to resolve this.
      if (!d3.event.sourceEvent.ctrlKey) {
        d.fx = null;
        d.fy = null
      }
    };

  }

  function dblclick(d) {
    d3.select(this).classed("fixed",false);
    //if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = null;
    d.fy = null;
  }


</script>
<script>
  class CalypearDiagramComponent {
    constructor(componentData = null,relationData = null) {
      if (componentData != null) {
        if (componentData.id) {
          this.id = componentData.id;
        }

        if (componentData.name) {
          this.id = componentData.name;
        }

        if (componentData.type) {
          this.type = {};
          if (componentData.type.id) {
            this.type.id = componentData.type.id;
          }
          if (componentData.type.name) {
            this.type.name = componentData.type.name;
          }
        }
      }

      if (relationData != null) {
        if (relationData instanceof Array) {
          this.addRelationships(relationData);
        } else {
          this.addRelationship(relationData);
        }
      }

    }

    addRelationship(relationData) {
      if (!this.relationships instanceof Array) {
        this.relationData = [];
      }

      if (relationData) {
        var newRelation = {};
        if (relationData.id) {
          newRelation.id = relationData.id;
        }
        if (relationData.from) {
          newRelation.from = relationData.from;
        }
        if (relationData.to) {
          newRelation.to = relationData.to;
        }
        if (relationData.type) {
          newRelation.type = {};
          if (relationData.type.id) {
            newRelation.type.id = relationData.type.id;
          }
          if (relationData.type.name) {
            newRelation.type.name = relationData.type.name;
          }
        }

        this.relationData.push(newRelation);
      }
      return this;
    }

    addRelationships(relationData) {
      if (relationData instanceof Array) {
        relationData.forEach(function(relation){
          this.addRelationship(relation);
        });
      }
      return this;
    }

    pinAt(x,y){
      this.fx = x;
      this.fy = y;

      return this;
    }

    pinRelease(){
      this.pin(null,null);

      return this;
    }

    isPinned(){
      return (this.fx != null) || (this.fy != null);
    }

    getRelationships() {
      return this.relationData;
    }
  }

  class CalypearDiagram  {
    constructor(components = null) {
      if (components instanceof Array) {
        this.components = components;
      } else {
        this.components = new Array();
      }
    }

    get nodes() {
      return this.components;
    }

    get edges() {
      var edges = [];
      this.components.forEach(function(component) {
        edges = edges.concat(component.getRelationships());
      })
      return edges;
    }

  }

  class CalypearVisualization {


  }




  /*
    Diagram Component Add/Remove/Filter and Save Functions
  */

</script>
