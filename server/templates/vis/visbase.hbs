<style>

.link-group path {
  stroke: #999;
  stroke-opacity: 0.6;
  fill: none;
  /*marker-end: url(#markerArrow);
  marker-mid: url(#markerArrow);*/
}


.node-group circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.node-text {
  font-size: 8px;
  text-align: center;
}

.diagram-link-label {
  font-size: 8px;
  text-align: center;
}
</style>
<svg width="100%" height="80%" viewBox="0 0 600 600">
  <defs>
    <marker id="markerArrow" markerWidth="13" markerHeight="13" refX="2" refY="6" orient="auto">
      <path d="M2,2 L2,11 L10,6 L2,2" style="fill: #000000;" />
    </marker>
  </defs>
</svg>
<script src="dist/js/d3.js"></script>
<script>

  var svg = d3.select("svg");
  width = 600;
  height = 600;
      // width = +svg.attr("width"),
      // height = +svg.attr("height");

  var color = d3.scaleOrdinal(d3.schemeCategory20);
  var connectorGenerator = d3.line()
    .curve(d3.curveBasis);


  function constructNode(context) {
    context.append("circle")
      .attr("cx",0)
      .attr("cy",0)
      .attr("r",6)
      .attr("fill",function(d) {return color(d.type.id)});
    context.append("foreignObject")
      .attr("x",-40)
      .attr("y",5)
      .attr("width",80)
      .attr("height",40)
      .attr("class","node-text")
      .append("xhtml:p")
        .text(function(d) {return d.name});
  }


  var simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(function(d) { return d.id; }))
      .force("charge", d3.forceManyBody())
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collide", d3.forceCollide(10))
      .on("tick",ticked);


  var link = svg.append("g")
      .attr("class", "link-group")
    .selectAll(".diagram-link");


    // .data(graph.links)
    // .enter()
    //   .append("path")
    //   .attr("class","linkitem")
    //   .attr("stroke-width", 1)
    //   .attr("id",function(d) {return "link"+d.id;});

  var linkLabels = svg.append("g")
      .attr("class","link-label-group")
    .selectAll(".diagra-link-label");
    // .data(graph.links)
    // .enter()
    //   .append("text")
    //   .attr("class","linklabel")
    //   .append("textPath")
    //     .attr("xlink:href",function(d) {return "#link"+d.id;})
    //     .attr("startOffset","50%")
    //     .text(function(d) {return d.type.name;});

  var node = svg.append("g")
      .attr("class", "node-group")
    .selectAll(".diagram-node")
    // .data(graph.nodes)
    // .enter()
    //   .append("g")
    //   .attr("class","nodeitem")
    //   .on("dblclick", dblclick)
    //   .call(d3.drag()
    //       .on("start", dragstarted)
    //       .on("drag", dragged)
    //       .on("end", dragended));

  // constructNode(node);

  // node.append('foreignObject')
  //   .attr("x",0)
  //   .attr("y",0)
  //   .attr("width",150)
  //   .attr("height",100)
  //   .append("xhtml:p")
  //     .text(function(d) { return d.name });


  // simulation
  //     .nodes(graph.nodes)
  //     .on("tick", ticked);
  //
  // simulation.force("link")
  //     .links(graph.links)
  //     .distance(function(link){return link.distanceAssoc*5;});

  function refresh(graphNodes, graphEdges){

    node = node.data(graphNodes);
    node.exit().remove();
    node = node.enter()
      .append("g")
      .attr("class","diagram-node")
      .on("dblclick", dblclick)
      .attr("id",function(d) {return "node"+d.id;})
      .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

    constructNode(node);
    node = svg.selectAll(".diagram-node");

    link = link.data(graphEdges);
    link.exit().remove();
    link = link.enter()
      .append("path")
      .attr("class","diagram-link")
      .attr("stroke-width", 1)
      .attr("id",function(d) {return "link"+d.id;});
      // .attr("d",function(d) {
      //   var points = [
      //     [d.source.x,d.source.y],
      //     [d.target.x,d.target.y]
      //   ];
      //   return connectorGenerator(points);
      // });;
    link = svg.selectAll(".diagram-link");

    simulation.nodes(graphNodes);
    simulation.force("link")
       .links(graphEdges);
      // .distance(function(link){return link.distanceAssoc*5;});
    simulation.alpha(1).restart();
  }

  //refresh(graph.nodes, graph.links);

  function ticked() {
    link
      .attr("d",function(d) {
        var points = [
          [d.source.x,d.source.y],
          [d.target.x,d.target.y]
        ];
        return connectorGenerator(points);
      });

    node
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  }

  function dragstarted(d) {
    d3.select(this).classed("fixed",true);
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
    //note in D3 \v4 .fixed setting no longer works need to use fx/fy
  }

  function dragged(d) {
    // d.fx = d3.event.x;
    // d.fy = d3.event.y;
    var grid = 10;

    d.fx = Math.round(d3.event.x/grid)*grid;
    d.fy = Math.round(d3.event.y/grid)*grid;

  }

  function dragended(d) {
    //Stop the simulation
    if (!d3.event.active) {
      simulation.alphaTarget(0)
      //If the Ctrl key is held down then lock the node in position
      //Touching the node again will free it
      //Need to resolve this.
      if (!d3.event.sourceEvent.ctrlKey) {
        d.fx = null;
        d.fy = null
      }
    };

  }

  function dblclick(d) {
    d3.select(this).classed("fixed",false);
    //if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = null;
    d.fy = null;
  }


</script>
<button id="tDump">Dump</button>
<script>
  class CalypearDiagramComponent {
    constructor(componentData,includedInDiagram) {
      if (componentData != null) {
        if (componentData.id) {
          this.id =componentData.id;
        }

        if (componentData.name) {
          this.name = componentData.name;
        }

        if (componentData.type) {
          this.type = {};
          if (componentData.type.id) {
            this.type.id = componentData.type.id;
          }
          if (componentData.type.name) {
            this.type.name = componentData.type.name;
          }
        }

        this.relationships = componentData.relationships;
        //Set the Source/Target fields
        this.relationships.forEach(function(relationship) {
          relationship.source = relationship.from;
          relationship.target = relationship.to;
        });

      }

      this.includedInDiagram = includedInDiagram;

    }


    pinAt(x,y){
      this.fx = x;
      this.fy = y;

      return this;
    }

    pinRelease(){
      this.pin(null,null);

      return this;
    }

    isPinned(){
      return (this.fx != null) || (this.fy != null);
    }

    included(includedInDiagram = true) {
      this.includedInDiagram = includedInDiagram
      return this;
    }

    isIncludedInDiagram() {
      return this.includedInDiagram;
    }

    getForwardRelationships() {
      return this.relationships.filter(function(relationship){
        return relationship.inverse == false
      });
    }

    getRelationships() {
      return this.relationships;
    }

    saveToDiagram(){
      return {
        archComponentId : this.id,
        fixedX : this.fx,
        fixedY : this.fy
      };
    }
  }

  class CalypearDiagram  {
    constructor() {
      this.diagramComponents = new Array();
      this.diagramName = 'Untitled';
    }

    name(name){
      if (name) {
        this.diagramName = name;
        return this;
      } else {
        return this.diagramName;
      }
    }

    nodes() {
      return this.diagramComponents;
    }

    edges() {
      var edges = [];
      var componentIds = [];
      //Pull out the relationships for all the diagram components
      this.diagramComponents.forEach(function(component) {
        edges = edges.concat(component.getRelationships());
        componentIds.push(component.id);
      });
      //Filter out relationships to unknown objects
      edges = edges.filter(function(relationship,index,relationsArray) {
        return (componentIds.includes(relationship.to) && (componentIds.includes(relationship.from)));
      });
      //Filter out inverse Relationships when a forward relationship exists
      return edges;
    }



    retrieveAndAddComponents(componentIds, refreshOnSuccess = true){
      var queryParams =  {
        componentId: componentIds,
        detailed: true,
      }
      var url = '/archcomponents';
      var current = this;
      $.ajax({
        dataType: "json",
        url: url,
        data: $.param(queryParams,true),
        context: {diagram: this},
        success: function(responseData) {
          var existingComponentIds = diagram.diagramComponents.map(function(ac){
            return ac.id;
          });
          if (responseData.archComponents) {
            responseData.archComponents.forEach(function(newComponent){
              //Check if the component already exists if so - ignore it
              if (!existingComponentIds.includes(newComponent.id)){
                diagram.diagramComponents.push(new CalypearDiagramComponent(newComponent,true));
              }
            });
          }
          if (refreshOnSuccess) {
            diagram.updateDiagram();
          }
        }
      });
    }

    updateDiagram(){
      refresh(this.nodes(), this.edges());
    }

    saveToDiagram(){
      returnObj = {
        components: [],
        name: this.diagramName,
      };
      this.components.forEach(function(diagramComponent) {
        returnObj.components.push(diagramComponent.saveToDiagram);
      });

      return returnObj;
    }

  }

  var diagram = new CalypearDiagram();
  //diagram.retrieveAndAddComponents([]);
  /*
    Diagram Component Add/Remove/Filter and Save Functions
  */

</script>
